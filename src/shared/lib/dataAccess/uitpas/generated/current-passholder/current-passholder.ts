/**
 * Generated by orval v6.19.1 üç∫
 * Do not edit manually.
 * UiTPAS API
 * With UiTPAS API 4.0 you can retrieve ticket prices and register ticket sales for passholders. You can also save UiTPAS points and exchange them for rewards for a passholder, and much more.
 * OpenAPI spec version: 4.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";
import axios from "axios";
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";
import type {
  Error,
  ForbiddenResponse,
  GetUitidPassholderRegistrationToken200,
  GetUitidPassholderStatus200,
  Passholder,
  PassholderSelfRegistration,
  UnauthorizedResponse,
} from "../model";

/**
 * This is step 1 of the process to register an UiTPAS passholder in UiTiD using their UiTPAS number and date of birth. It is used to retrieve an UiTiD registration token for the passholder. If the passholder already has a token via an email they received to register in UiTiD, this step can be skipped.

This endpoint uses [HTTP Basic Authentication](https://datatracker.ietf.org/doc/html/rfc7617) using:
* Username: uitpasNumber 
* Password: dateOfBirth in the form yyyy-mm-dd

In summary, this header should look like: 

```
Authorization: Basic base64(uitpasNumber:dateOfBirth)
```

The response will contain a `token` property that can be used in step 2 of the process, [retrieving the UiTiD registration status](/reference/uitpas.json/paths/~1passholders~1me~1uitid~1status/get).

This caller of this method is identified with [client identification](https://docs.publiq.be/docs/authentication/ZG9jOjExODE5NDY5-client-identification) and does not require any permissions, but please note this endpoint is rate-limited on IP address to prevent abuse.
 * @summary Retrieve UiTiD registration token
 */
export const getUitidPassholderRegistrationToken = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<GetUitidPassholderRegistrationToken200>> => {
  return axios.get(
    `NEXT_PUBLIC_API_PATH/passholders/me/uitid/registration-token`,
    options
  );
};

export const getGetUitidPassholderRegistrationTokenQueryKey = () => {
  return [
    `NEXT_PUBLIC_API_PATH/passholders/me/uitid/registration-token`,
  ] as const;
};

export const getGetUitidPassholderRegistrationTokenQueryOptions = <
  TData = Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>,
  TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | Error>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUitidPassholderRegistrationTokenQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>
  > = ({ signal }) =>
    getUitidPassholderRegistrationToken({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUitidPassholderRegistrationTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>
>;
export type GetUitidPassholderRegistrationTokenQueryError = AxiosError<
  UnauthorizedResponse | ForbiddenResponse | Error
>;

/**
 * @summary Retrieve UiTiD registration token
 */
export const useGetUitidPassholderRegistrationToken = <
  TData = Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>,
  TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | Error>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getUitidPassholderRegistrationToken>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getGetUitidPassholderRegistrationTokenQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Retrieves the UiTiD registration status of a passholder. This is step 2 in the process of registering an UiTPAS passholder in UiTiD.

This endpoint requires a registation token in the `x-registration-token` header. A client can obtain such a token using [`GET /passholders/me/uitid/registration-token`](/reference/uitpas.json/paths/~1passholders~1me~1uitid~1registration-token/get). Alternatively, a token may already be available to the client because the user may have received an email link including it.

Based on the state value, the client can proceed in 2 ways:

- If state is `UNREGISTERED`

The passholder can proceed to step 3, [retrieving the UiTiD email address status](/reference/uitpas.json/paths/~1uitid~1emails~1{email}/get).

The response can include the linked `email` address of the passholder if one is known. This can be used in the next step of the registration process ([`GET /uitid/emails/{email}`](/reference/uitpas.json/paths/~1uitid~1emails~1{email}/get)). If no email address is included, the client should prompt the user to enter their email address first before proceeding to step 3.

- If state is `REGISTERED` 

The passholder is already `REGISTERED` so the user must continue by authenticating instead. The `email` address field contains the email address of the linked UiTiD account that should be used to authenticate.


This caller of this method, identified with [client identification](https://docs.publiq.be/docs/authentication/ZG9jOjExODE5NDY5-client-identification) does not require any permissions.
 * @summary Retrieve UiTiD registration status
 */
export const getUitidPassholderStatus = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<GetUitidPassholderStatus200>> => {
  return axios.get(`NEXT_PUBLIC_API_PATH/passholders/me/uitid/status`, options);
};

export const getGetUitidPassholderStatusQueryKey = () => {
  return [`NEXT_PUBLIC_API_PATH/passholders/me/uitid/status`] as const;
};

export const getGetUitidPassholderStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getUitidPassholderStatus>>,
  TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | Error>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getUitidPassholderStatus>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUitidPassholderStatusQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUitidPassholderStatus>>
  > = ({ signal }) => getUitidPassholderStatus({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUitidPassholderStatus>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUitidPassholderStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUitidPassholderStatus>>
>;
export type GetUitidPassholderStatusQueryError = AxiosError<
  UnauthorizedResponse | ForbiddenResponse | Error
>;

/**
 * @summary Retrieve UiTiD registration status
 */
export const useGetUitidPassholderStatus = <
  TData = Awaited<ReturnType<typeof getUitidPassholderStatus>>,
  TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | Error>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getUitidPassholderStatus>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUitidPassholderStatusQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Registers the UiTiD for this passholder. This is step 4, and the final step, in the process of registering an UiTPAS passholder in UiTiD.

This request requires an `Authorization` header with the [user access token](https://docs.publiq.be/docs/authentication/ZG9jOjExODE5NTM5-user-access-token) of an authenticated UiTiD *and* it requires a `x-registration-token` header containing a valid registration token of the passholder.

A user access token of a client with `PASSHOLDERS_REGISTER_UITID` permission is mandatory.
 * @summary Register UiTiD for passholder
 */
export const registerUitidPassholder = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.put(
    `NEXT_PUBLIC_API_PATH/passholders/me/uitid`,
    undefined,
    options
  );
};

export const getRegisterUitidPassholderMutationOptions = <
  TError = AxiosError<Error | UnauthorizedResponse | ForbiddenResponse>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof registerUitidPassholder>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof registerUitidPassholder>>,
  TError,
  TVariables,
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof registerUitidPassholder>>,
    TVariables
  > = () => {
    return registerUitidPassholder(axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RegisterUitidPassholderMutationResult = NonNullable<
  Awaited<ReturnType<typeof registerUitidPassholder>>
>;

export type RegisterUitidPassholderMutationError = AxiosError<
  Error | UnauthorizedResponse | ForbiddenResponse
>;

/**
 * @summary Register UiTiD for passholder
 */
export const useRegisterUitidPassholder = <
  TError = AxiosError<Error | UnauthorizedResponse | ForbiddenResponse>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof registerUitidPassholder>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getRegisterUitidPassholderMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Allows users to retrieve their passholder using a user access token.

A user access token of a client with `PASSHOLDERS_SELF_READ` permission is mandatory. The passholder is retrieved by `inszNumber` if the access token contains the custom claim `https://publiq.be/rrn` (i.e. user has logged in using connection ACM), or by linked UiTiD user (`sub` or `https://publiq.be/uitidv1id` claim of the user access token).
 * @summary Retrieve passholder for the current user
 */
export const getPassholdersMe = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Passholder>> => {
  return axios.get(`NEXT_PUBLIC_API_PATH/passholders/me`, options);
};

export const getGetPassholdersMeQueryKey = () => {
  return [`NEXT_PUBLIC_API_PATH/passholders/me`] as const;
};

export const getGetPassholdersMeQueryOptions = <
  TData = Awaited<ReturnType<typeof getPassholdersMe>>,
  TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | Error>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getPassholdersMe>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPassholdersMeQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPassholdersMe>>
  > = ({ signal }) => getPassholdersMe({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPassholdersMe>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPassholdersMeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPassholdersMe>>
>;
export type GetPassholdersMeQueryError = AxiosError<
  UnauthorizedResponse | ForbiddenResponse | Error
>;

/**
 * @summary Retrieve passholder for the current user
 */
export const useGetPassholdersMe = <
  TData = Awaited<ReturnType<typeof getPassholdersMe>>,
  TError = AxiosError<UnauthorizedResponse | ForbiddenResponse | Error>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getPassholdersMe>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetPassholdersMeQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * <!-- theme: warning -->

> WARNING
>
> Experimental API. Breaking changes might be introduced in future updates.

Allows users to self-register a passholder using a user access token.

A user access token of a client with `PASSHOLDERS_SELF_REGISTRATION` permission for the `registrationOrganizer` is mandatory. Furthermore, the user access token must contain the custom claim `https://publiq.be/rrn` (i.e. user has to login using connection ACM).

Please note a user can only self-register one passholder. Use `GET /passholders/me` to check if a passholder already exists for this user.
 * @summary Register passholder for the current user
 */
export const postPassholdersMe = (
  passholderSelfRegistration: PassholderSelfRegistration,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Passholder>> => {
  return axios.post(
    `NEXT_PUBLIC_API_PATH/passholders/me`,
    passholderSelfRegistration,
    options
  );
};

export const getPostPassholdersMeMutationOptions = <
  TError = AxiosError<Error | UnauthorizedResponse | ForbiddenResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postPassholdersMe>>,
    TError,
    { data: PassholderSelfRegistration },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postPassholdersMe>>,
  TError,
  { data: PassholderSelfRegistration },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postPassholdersMe>>,
    { data: PassholderSelfRegistration }
  > = (props) => {
    const { data } = props ?? {};

    return postPassholdersMe(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostPassholdersMeMutationResult = NonNullable<
  Awaited<ReturnType<typeof postPassholdersMe>>
>;
export type PostPassholdersMeMutationBody = PassholderSelfRegistration;
export type PostPassholdersMeMutationError = AxiosError<
  Error | UnauthorizedResponse | ForbiddenResponse
>;

/**
 * @summary Register passholder for the current user
 */
export const usePostPassholdersMe = <
  TError = AxiosError<Error | UnauthorizedResponse | ForbiddenResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postPassholdersMe>>,
    TError,
    { data: PassholderSelfRegistration },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getPostPassholdersMeMutationOptions(options);

  return useMutation(mutationOptions);
};
